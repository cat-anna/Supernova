#include "IFILES_Volume.h"
#include <string.h>
#include <stdio.h>
#include <time.h>

using namespace std;

char Root_Path[] = "\\";

unsigned Glob_ID = 0;

enum {
    IFILES_TYPE_ASM = 0x10,

    STATUS_FILE_CHECKED     = (1 << 20),

    VOLUME_NODE_FLAG_ROOT           = 0x0200,

    VOLUME_NODE_FLAG_DIR            = 0x0020,
    VOLUME_NODE_FLAG_READ_ONLY      = 0x0002,
};

#define ROOT_NAME "IVolume"

char ASM_FILE_HEADER[] =    ";file generated by Supernova System Manager\n\nbits 32\n"
                            "section .IVolume_data\n\n";
char ASM_FILE_FOOTER[] =    "section .IVolume_structure\n\n";

IFILES_Volume::IFILES_Volume(char* fname, char* format) :VolumeInterface(0){
   /* FName = new char[strlen(fname) + 1];
    strcpy(FName, fname);
    type = IFILES_TYPE_ASM;

    HANDLE h = WIN::CreateFileA(fname, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    if(h == INVALID_HANDLE_VALUE) WinH = 0;
    else WinH = (unsigned)h;

    switch(type) {
    case IFILES_TYPE_ASM:
        DWORD r;
        WIN::WriteFile((HANDLE)WinH, ASM_FILE_HEADER, strlen(ASM_FILE_HEADER), &r, NULL);
        break;
    }

    node_root = new IFILES_node(ROOT_NAME, VOLUME_NODE_FLAG_ROOT | VOLUME_NODE_FLAG_READ_ONLY | VOLUME_NODE_FLAG_DIR, this);
    WriteFileData(node_root);*/
//printf("IFILES_Volume\n");
//	if(!strcmp(format, "ASM")) type = IFILES_TYPE_ASM;
//	else
}

IFILES_Volume::~IFILES_Volume() {
   /* switch(type) {
    case IFILES_TYPE_ASM:
        DWORD r;
        WIN::WriteFile((HANDLE)WinH, ASM_FILE_FOOTER, strlen(ASM_FILE_FOOTER), &r, NULL);
        break;
    }
    node_root->WriteStructure((unsigned)WinH);

    WIN::CloseHandle((HANDLE)WinH);
    delete node_root;*/
}

void IFILES_Volume::InsertFile(char* vname, char* sysname) {
   /* IFILES_node *node = new IFILES_node(sysname, vname, this);
    if(node->CheckSysFile()) {
        delete node;
        printf("IFILES: \"%s\" caused check error!\n", sysname);
        return;
    }

    WriteFileData(node);
    node_root->AddFile(node);*/
}

void IFILES_Volume::WriteFileData(IFILES_node *file) {
   /* char* buffer = (char*)malloc(500);
    ZeroMemory(buffer, 500);
    switch (type) {
    case IFILES_TYPE_ASM: {
        DWORD r;
        unsigned len = sprintf(buffer, "global %s_name\n%s_name: db '%s', 0\n",
                               file->label, file->label, file->name);
        WIN::WriteFile((HANDLE)WinH, buffer, len, &r, NULL);
        if(!(file->attributes & VOLUME_NODE_FLAG_DIR)) {
            unsigned len = sprintf(buffer, "global %s_data\n%s_data: db ",
                                   file->label, file->label);
            WIN::WriteFile((HANDLE)WinH, buffer, len, &r, NULL);
        }
        break;
    }
    }

    file->WriteFileData((unsigned)WinH);
    ZeroMemory(buffer, 500);

    switch (type) {
    case IFILES_TYPE_ASM: {
        DWORD r;
        unsigned len = sprintf(buffer, (file->attributes & VOLUME_NODE_FLAG_DIR)?("\n"):("\n\n"));
        WIN::WriteFile((HANDLE)WinH, buffer, len, &r, NULL);
    }
    break;
    }

    free(buffer);*/
}

void IFILES_Volume::List(){
    /*node_root->ListTree();*/
}

//---------------------------------IFILES_node------------------------------------------------------

#include "../../source/include/utils/IVolume.h"

int IFILES_node::CheckSysFile() {
   /* if((Status & STATUS_FILE_CHECKED) || !sys_name)return 0;
    WIN::HANDLE h = WIN::CreateFileA(sys_name, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if(h == INVALID_HANDLE_VALUE) return 10;
    WIN::FILETIME ft;
    WIN::GetFileTime(h, 0, 0, &ft);
    WIN::SYSTEMTIME s;
    WIN::FileTimeToSystemTime(&ft, &s);
    FileDate = EncodeDate_SFS(s.wYear, s.wMonth, s.wDay, s.wHour, s.wMinute);
    FileSize = WIN::GetFileSize(h, NULL);

    WIN::CloseHandle(h);
    Status |= STATUS_FILE_CHECKED;*/
    return 0;
}

int IFILES_node::WriteFileData(unsigned F) {
 /*   if(!sys_name)return 0;
    if(CheckSysFile())return 10;

    HANDLE h_out = (HANDLE)F;
    if(h_out == INVALID_HANDLE_VALUE)return 1;

    WIN::HANDLE h_in = WIN::CreateFileA(sys_name, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if(h_in == INVALID_HANDLE_VALUE) return 2;

    char* buffer = (char*)malloc(FileSize + 1);
    ZeroMemory(buffer, FileSize + 1);

    char* file_text = (char*)malloc(FileSize * 10 + 1);
    ZeroMemory(file_text, FileSize * 10 + 1);
    unsigned text_len = 0;
    DWORD r;
    if(WIN::ReadFile(h_in, buffer, FileSize, &r, NULL)) {
        unsigned r = FileSize;
        char* t = file_text;
        char* buf = buffer;
        while(r--) { // "0xFF, "
            unsigned d = sprintf(t, "0x%.2x, ", (*buf++) & 0xFF);
            t += d;
            text_len += d;
        }
    }
    WIN::WriteFile(h_out, file_text, text_len, &r, NULL);

    free(buffer);
    free(file_text);
    WIN::CloseHandle(h_in);*/
    return 0;
}

char No_Node[] = "0x0;";

void IFILES_node::WriteStructure(unsigned handle) {
    /*HANDLE h = (HANDLE)handle;

    char buffer[500];
    ZeroMemory(buffer, 500);

    unsigned len;
    DWORD r;

    unsigned f_date = (FileDate)?(FileDate):(GetSystemTime_SFS());
    char *f_data = (!(attributes & (VOLUME_NODE_FLAG_ROOT | VOLUME_NODE_FLAG_DIR)))?(label):(No_Node);

    char *n_next = (next)?(next->label):(No_Node);
    char *n_chil = (child)?(child->label):(No_Node);

    len = sprintf(buffer,
                  "global %s\n"
                  "%s:\n"
                  "db 0x%.2x\t;size\n"   //unsigned char ssize;
                  "dd %s_name\t;name\n"  //char* Name;
                  "dd 0x%x\t;size\n"     //unsigned fsize;
                  "dw 0x%x\t;flags\n"    //short flags;
                  "dd 0x%x\t;time\n"     //unsigned time;
                  "dd %s_data\t;data\n"  //void *fdata;
                  "dd %s\t;next\n"       //void *Next;
                  "dd %s\t;child\n\n",   //void *Children;
                  label, label, sizeof(IVolume_t),
                  label, FileSize, attributes, f_date, f_data,
                  n_next, n_chil);

    WIN::WriteFile(h, buffer, len, &r, NULL);

    if(child)child->WriteStructure(handle);
    if(next)next->WriteStructure(handle);*/
}

void IFILES_node::Clean() {
   /* if(next) {
        delete next;
        next = 0;
    }
    if(child) {
        delete child;
        child = 0;
    }
    if(label) {
        delete label;
        label = 0;
    }
    if(name) {
        delete name;
        name = 0;
    }
    if(path) {
        delete path;
        path = 0;
    }
    if(sys_name) {
        delete sys_name;
        sys_name = 0;
    }*/
}

void IFILES_node::AddFile(IFILES_node *f) {
    /*if(!f || !f->path)return;
    char* path = (char*)malloc(strlen(f->path) + 1);
    strcpy(path, f->path);
    IFILES_node *n = (child)?(child):(this);

    if(*path == '\\')path++;
//   printf("\n%s %s\n", path, f->file->name);
    char* pos;
    bool skip = false;
    while(*path) {
        if(!skip) {
            pos = strchr(path, '\\');
            if(pos)*pos++ = 0;
        } else skip = false;

//       printf("\tAddFile |%s|%s|\n", n->file->name, path);
        if(strcmp(n->name, path) == 0) {
            n = n->child;
            //         printf("\t\tchild\n");
        } else {
            //          printf("\t\tnext %x\n", n->file_next);
            if(!n->next) {
                //     printf("!n->file_next\n");
                IFILES_node *new_node = new IFILES_node(path, VOLUME_NODE_FLAG_DIR, Volume);
                Volume->WriteFileData(new_node);

                if(n->attributes & VOLUME_NODE_FLAG_ROOT) {
                    n->InsertChild(new_node);
                } else {
                    n->InsertNext(new_node);
                }
                n = new_node;
            } else {
                n = n->next;
                skip = true;
                continue;
            }
        }
        path = pos;
    }

    if(n->attributes & VOLUME_NODE_FLAG_DIR) {
        n->InsertChild(f);
    } else {
        n->InsertNext(f);
    }

    free(path);*/
}

const char HEXCH[] = "0123456789ABCDEF";

void IFILES_node::DoGenLabel(char* src) {
   /* label = new char [strlen(src) + 5];
    strcpy(label, src);
    if(attributes & VOLUME_NODE_FLAG_ROOT)return;
    char *gen = label;

    while(*gen) {
        if(strchr("./\\", *gen)) *gen = '_';
        *gen++;
    }
    *gen++ = '_';
    *gen++ = HEXCH[(Glob_ID >> 8) & 0xF];
    *gen++ = HEXCH[(Glob_ID >> 4) & 0xF];
    *gen++ = HEXCH[(Glob_ID >> 0) & 0xF];
    *gen = 0;
    Glob_ID++;*/
}

IFILES_node::~IFILES_node() {
   /* Clean();*/
}

IFILES_node::IFILES_node(const char* lab, short flags, IFILES_Volume *Vol) {
   /* child = 0;
    next = 0;
    name = sys_name = label = path = 0;
    attributes = flags | VOLUME_NODE_FLAG_READ_ONLY;
    DoGenLabel((char*)lab);
    Volume = Vol;
    FileDate = FileSize = Status = 0;
    name = new char[strlen(lab) + 1];
    strcpy(name, lab);*/
}

IFILES_node::IFILES_node(char *sys, char* vol, IFILES_Volume *Vol) {
   /* child = 0;
    next = 0;
    name = sys_name = label = path = 0;
    Volume = Vol;
    attributes = VOLUME_NODE_FLAG_READ_ONLY;
    FileDate = FileSize = Status = 0;
    SetPaths(sys, vol);
    DoGenLabel(name);*/
}

void IFILES_node::ListTree(){
  /*  SubListTree(this, 0);*/
}

void IFILES_node::SubListTree(IFILES_node *node, unsigned level) {
  /*  while(node) {
        unsigned i = level;
        for(; i > 0; i--)printf("\t");
        printf("%s\n", node->name);
        if(node->attributes & VOLUME_NODE_FLAG_DIR) SubListTree(node->child, level + 1);
        node = node->next;
    }*/
}

void IFILES_node::SetPaths(char *sys, char* vol) {
 /*   if(sys) {
        sys_name = new char[strlen(sys) + 1];
        strcpy(sys_name, sys);

        char* t_n = 0;
        if((t_n = strrchr(sys_name, '\\')) == 0 && (t_n = strrchr(sys_name,  '/')) == 0)
            t_n = sys_name;
        if(*t_n == '\\' || *t_n == '/')t_n++;
        name = new char[strlen(t_n) + 1];
        strcpy(name, t_n);

        if(!vol || !*vol) {
            path = new char[strlen(Root_Path) + 1];
            strcpy(path, Root_Path);
        } else {
            path = new char[strlen(vol) + 1];
            strcpy(path, vol);
        }
    } else {
        name = new char[strlen(vol) + 1];
        strcpy(name, vol);
        sys_name = 0;
    }*/
}

void IFILES_node::InsertChild(IFILES_node *n) {
  /*  if(!child)child = n;
    else {
        IFILES_node *c = child;
        while(c->next)c = c->next;
        c->next = n;
    }*/
}

void IFILES_node::InsertNext(IFILES_node *n) {
   /* if(!next)next = n;
    else {
        IFILES_node *c = next;
        while(c->next)c = c->next;
        c->next = n;
    }*/
}
